{"title":"GDAL Rasters","markdown":{"yaml":{"title":"GDAL Rasters"},"headingText":"Spatial data in Jupyter","containsRefs":false,"markdown":"\n\n\n\n\nFor spatial data, the amazing workhorse is GDAL (I realize now I use the word workhorse waaaaaay way too much). You might remember this name from RGDAL.\nThe open-source scientific computing stack is all interlinked.\n\n\nFirst we're going to  import gdal, numpy and a few other things. \n\n\n\nFirst, define the path to our raster data. This is remarkably difficult (at least, as measured by how many hours I have wasted because my code pointed to the wrong place). A the superior way to manage this is with RELATIVE PATHS. Here, we define the filename, the directory in relative terms, and then join them together using the os functions.\n\n\nIt's often easy to get confused by relative paths, accidentally missing a level or something. One way to trouble-shoot this is to view the current working direcotry:\n\nOr to view the absolute path:\n\nSometimes it can be useful to see what is in the directory you've specified (to help you figure out what's going on if it can't find the file)\n\n## GDAL and opening the raster\n\nNow that we know for sure that the file is there, we can use gdal and it's Open function using the DOT notation (technically its a \"method\" not a function, but you can ignore that. If you're actually curious about object-oriented programming, a method is just a function attached to an object.).\n\nThe dataset object holds information about the area and extent of the data, or the geotransform information\n\nIMPORTANT ANNOYING NOTE: in programming, there are different conventions for identifying a place by rows, cols vs. x, y vs. upper-left, lower-right, etc.\nNumpy is denoted row, col but gdal is denoted X, Y (which flips the order). Just memorize that row = Y and col = X.\n\nNext, get the \"band\" of the dataset. Many datasets have multiple layers (e.g. NetCDFs).\nGeotiffs can have multiple bands but often have just 1. For now, grab band 1\n\nThe band object has information too, like the datatype of the geotiff:\n\nFinally, we can get the array from the band as a numpy array:\n\n## Plotting a raster\n\nWe are now going to use matplotlib. It is basically like ggplot and draws its inspiration from MATLAB notation. By convention, we'll import it into the variable name plt, which is an object that lets us use matplotlib plotting notation.\n\nThis is super ugly for one primary reason: it has scaled the colorbar to the minimum and maximum values, which ends up coloring nearly everything close to the zero value. We're going to crop the values it shoes to not let the outliers define the colorbar range.\n\n## Copies versus Views in Numpy \n\nPart of how Numpy arrays are fast is the only ever load or access data when it is needed. This means that if you don't tell numpy to make a copy of something, any new variable will point to the old array. More specifically, this only creates a new pointer to the same block of memory on your computer that holds the array. If we change c_view, c will also be changed. So in the below, c_view only points to the old data in c. This is called a \"view\" of the array.\n\n\n\nThis also means that if you modify array, you will be modifying what you have in c_view.\n\nIf you really need a copy in memory, you can use the numpy method copy():\n\nThis gives us a NEW array in a new block of memory, so changing array will not change d,\n\n## In-class exercise 4.1\n\nHere you will use GDAL and numpy to do some highly-optimized raster manipulation.\n\nUsing data from Earthstat, I want you to calculate the production per grid-cell of Maize, globally, at \"high\"-resolution.\n\nThe two files you need are in your class data directory (obtained from google drive). On my computer they are saved in the following locations.\n\n```\nD:\\My Drive\\Files\\Teaching\\APEC 8222\\Data\\maize_HarvestedAreaHectares.tif\nD:\\My Drive\\Files\\Teaching\\APEC 8222\\Data\\maize_YieldPerHectare.tif\n```\n\nUse the os.path.join() approach from earlier to correcly make relative paths (NOT ABSOLUTE PATHS LIKE I PASTED ABOVE) pointing to the two files.\n\nOpen them up as raster using Gdal. \n\nMultiply the HarvestedAreaHectars by YieldPerHectare. This will give you the total production on the grid-cell.\n\nUse numpy to sum up the total production of Maize globally and report that to the class.\n\n\n\n# Saving a raster to your harddrive \n\nNow that you've created an amazing raster of total maize production, you might want to save it to your harddrive.\n\nTo do this, we're first going to define a new filename for our output file. In the code below, + concatenates things. Str() makes the number a string.\n\nCreate a new file at that filename location using the attributes we used above. Notice that we flipped n_cols and n_rows from how numpy would have wanted it. For extra BONUS value, replace the d array with the one you created in the in-class exercise.\n\nSet dataset-level information. Here we're just using what we got from the input raster, defined above.\n\nNow get a band from our new dataset on which we'll write our array.\n\nDo the array writing\n\nSet any final band-level information\n\nFinally, and very importantly, clean up after yourself. It wont actually write until the resources in\nmemory have been released.\n","srcMarkdownNoYaml":"\n\n\n\n\nFor spatial data, the amazing workhorse is GDAL (I realize now I use the word workhorse waaaaaay way too much). You might remember this name from RGDAL.\nThe open-source scientific computing stack is all interlinked.\n\n## Spatial data in Jupyter\n\nFirst we're going to  import gdal, numpy and a few other things. \n\n\n\nFirst, define the path to our raster data. This is remarkably difficult (at least, as measured by how many hours I have wasted because my code pointed to the wrong place). A the superior way to manage this is with RELATIVE PATHS. Here, we define the filename, the directory in relative terms, and then join them together using the os functions.\n\n\nIt's often easy to get confused by relative paths, accidentally missing a level or something. One way to trouble-shoot this is to view the current working direcotry:\n\nOr to view the absolute path:\n\nSometimes it can be useful to see what is in the directory you've specified (to help you figure out what's going on if it can't find the file)\n\n## GDAL and opening the raster\n\nNow that we know for sure that the file is there, we can use gdal and it's Open function using the DOT notation (technically its a \"method\" not a function, but you can ignore that. If you're actually curious about object-oriented programming, a method is just a function attached to an object.).\n\nThe dataset object holds information about the area and extent of the data, or the geotransform information\n\nIMPORTANT ANNOYING NOTE: in programming, there are different conventions for identifying a place by rows, cols vs. x, y vs. upper-left, lower-right, etc.\nNumpy is denoted row, col but gdal is denoted X, Y (which flips the order). Just memorize that row = Y and col = X.\n\nNext, get the \"band\" of the dataset. Many datasets have multiple layers (e.g. NetCDFs).\nGeotiffs can have multiple bands but often have just 1. For now, grab band 1\n\nThe band object has information too, like the datatype of the geotiff:\n\nFinally, we can get the array from the band as a numpy array:\n\n## Plotting a raster\n\nWe are now going to use matplotlib. It is basically like ggplot and draws its inspiration from MATLAB notation. By convention, we'll import it into the variable name plt, which is an object that lets us use matplotlib plotting notation.\n\nThis is super ugly for one primary reason: it has scaled the colorbar to the minimum and maximum values, which ends up coloring nearly everything close to the zero value. We're going to crop the values it shoes to not let the outliers define the colorbar range.\n\n## Copies versus Views in Numpy \n\nPart of how Numpy arrays are fast is the only ever load or access data when it is needed. This means that if you don't tell numpy to make a copy of something, any new variable will point to the old array. More specifically, this only creates a new pointer to the same block of memory on your computer that holds the array. If we change c_view, c will also be changed. So in the below, c_view only points to the old data in c. This is called a \"view\" of the array.\n\n\n\nThis also means that if you modify array, you will be modifying what you have in c_view.\n\nIf you really need a copy in memory, you can use the numpy method copy():\n\nThis gives us a NEW array in a new block of memory, so changing array will not change d,\n\n## In-class exercise 4.1\n\nHere you will use GDAL and numpy to do some highly-optimized raster manipulation.\n\nUsing data from Earthstat, I want you to calculate the production per grid-cell of Maize, globally, at \"high\"-resolution.\n\nThe two files you need are in your class data directory (obtained from google drive). On my computer they are saved in the following locations.\n\n```\nD:\\My Drive\\Files\\Teaching\\APEC 8222\\Data\\maize_HarvestedAreaHectares.tif\nD:\\My Drive\\Files\\Teaching\\APEC 8222\\Data\\maize_YieldPerHectare.tif\n```\n\nUse the os.path.join() approach from earlier to correcly make relative paths (NOT ABSOLUTE PATHS LIKE I PASTED ABOVE) pointing to the two files.\n\nOpen them up as raster using Gdal. \n\nMultiply the HarvestedAreaHectars by YieldPerHectare. This will give you the total production on the grid-cell.\n\nUse numpy to sum up the total production of Maize globally and report that to the class.\n\n\n\n# Saving a raster to your harddrive \n\nNow that you've created an amazing raster of total maize production, you might want to save it to your harddrive.\n\nTo do this, we're first going to define a new filename for our output file. In the code below, + concatenates things. Str() makes the number a string.\n\nCreate a new file at that filename location using the attributes we used above. Notice that we flipped n_cols and n_rows from how numpy would have wanted it. For extra BONUS value, replace the d array with the one you created in the in-class exercise.\n\nSet dataset-level information. Here we're just using what we got from the input raster, defined above.\n\nNow get a band from our new dataset on which we'll write our array.\n\nDo the array writing\n\nSet any final band-level information\n\nFinally, and very importantly, clean up after yourself. It wont actually write until the resources in\nmemory have been released.\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":true,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","output-file":"gdal_rasters.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.433","bibliography":["../references.bib"],"theme":"cosmo","title":"GDAL Rasters"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}