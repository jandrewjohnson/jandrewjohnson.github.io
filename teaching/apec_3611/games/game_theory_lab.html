<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game Theory Lab</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f5f7fa;
            color: #2d3748;
            min-height: 100vh;
            padding: 16px;
        }

        h1 {
            text-align: center;
            color: #1a202c;
            font-size: 1.7rem;
            font-weight: 700;
            margin-bottom: 2px;
        }

        .subtitle {
            text-align: center;
            color: #718096;
            font-size: 0.92rem;
            margin-bottom: 16px;
        }

        .app-grid {
            max-width: 1440px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 270px 1fr 1fr;
            grid-template-rows: auto auto auto;
            gap: 14px;
        }

        .panel {
            background: #ffffff;
            border: 1px solid #e2e8f0;
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.06);
        }

        .panel-title {
            font-size: 0.78rem;
            text-transform: uppercase;
            letter-spacing: 1.1px;
            color: #718096;
            margin-bottom: 12px;
            font-weight: 600;
        }

        .controls-panel { grid-row: 1 / 4; }

        /* Sliders */
        .slider-group { margin-bottom: 12px; }

        .slider-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
        }

        .slider-label span:first-child {
            font-size: 0.8rem;
            color: #4a5568;
            font-weight: 500;
        }

        .slider-value {
            background: #edf2f7;
            color: #2b6cb0;
            padding: 2px 8px;
            border-radius: 6px;
            font-size: 0.76rem;
            font-weight: 600;
            font-family: 'Consolas', monospace;
            min-width: 28px;
            text-align: center;
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 5px;
            border-radius: 3px;
            background: #e2e8f0;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px; height: 16px;
            border-radius: 50%;
            background: #4299e1;
            cursor: pointer;
            box-shadow: 0 1px 3px rgba(66,153,225,0.4);
        }

        input[type="range"]::-moz-range-thumb {
            width: 16px; height: 16px;
            border-radius: 50%;
            background: #4299e1;
            cursor: pointer;
            border: none;
        }

        .section-divider {
            border: none;
            border-top: 1px solid #e2e8f0;
            margin: 14px 0;
        }

        .info-box {
            background: #f7fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 10px;
            margin-top: 10px;
            font-size: 0.78rem;
            line-height: 1.5;
            color: #4a5568;
        }

        .info-box.highlight { border-left: 3px solid #4299e1; }
        .info-box.warning { border-left: 3px solid #e53e3e; background: #fff5f5; }
        .info-box.success { border-left: 3px solid #38a169; background: #f0fff4; }
        .info-box strong { color: #1a202c; }

        .equation-box {
            background: #f7fafc;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            padding: 7px 10px;
            font-family: 'Consolas', monospace;
            font-size: 0.72rem;
            color: #4a5568;
            margin: 6px 0;
            line-height: 1.5;
        }

        /* Game type badges */
        .game-type-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.82rem;
            font-weight: 700;
            margin-bottom: 8px;
        }

        /* Payoff matrix */
        .matrix-container {
            margin: 10px 0;
        }

        .payoff-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85rem;
        }

        .payoff-table th {
            padding: 8px 6px;
            font-size: 0.72rem;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            color: #718096;
            font-weight: 600;
        }

        .payoff-table td {
            padding: 12px 8px;
            text-align: center;
            border: 1px solid #e2e8f0;
            font-family: 'Consolas', monospace;
            font-size: 0.9rem;
            position: relative;
            transition: all 0.2s;
            cursor: default;
        }

        .payoff-table td .p1 {
            color: #2b6cb0;
            font-weight: 700;
        }

        .payoff-table td .p2 {
            color: #e53e3e;
            font-weight: 700;
        }

        .payoff-table td.nash {
            background: #f0fff4;
            border-color: #38a169;
            box-shadow: inset 0 0 0 2px rgba(56,161,105,0.3);
        }

        .payoff-table td.pareto-optimal {
            position: relative;
        }

        .payoff-table td.pareto-optimal::after {
            content: '‚òÖ';
            position: absolute;
            top: 2px;
            right: 4px;
            font-size: 0.6rem;
            color: #d69e2e;
        }

        .payoff-table .row-label {
            text-align: right;
            padding-right: 12px;
            border: none;
            font-weight: 600;
            color: #2b6cb0;
            font-family: 'Segoe UI', sans-serif;
            font-size: 0.82rem;
        }

        .payoff-table .col-header {
            text-align: center;
            color: #e53e3e;
        }

        .payoff-table .corner {
            border: none;
        }

        /* Action buttons */
        .action-buttons {
            display: flex;
            gap: 10px;
            margin: 14px 0;
        }

        .action-btn {
            flex: 1;
            padding: 14px 8px;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            background: #ffffff;
            cursor: pointer;
            text-align: center;
            transition: all 0.15s;
            font-family: 'Segoe UI', sans-serif;
        }

        .action-btn:hover {
            border-color: #4299e1;
            background: #ebf8ff;
            transform: translateY(-1px);
        }

        .action-btn:active {
            transform: translateY(0);
        }

        .action-btn .btn-label {
            font-size: 0.9rem;
            font-weight: 700;
            color: #1a202c;
            display: block;
        }

        .action-btn .btn-sub {
            font-size: 0.7rem;
            color: #718096;
            margin-top: 2px;
        }

        .action-btn.cooperate:hover { border-color: #38a169; background: #f0fff4; }
        .action-btn.defect:hover { border-color: #e53e3e; background: #fff5f5; }

        /* Round result */
        .round-result {
            padding: 12px;
            border-radius: 10px;
            margin: 10px 0;
            text-align: center;
            font-size: 0.88rem;
            line-height: 1.5;
            display: none;
        }

        .round-result.show { display: block; }

        /* History */
        .history-scroll {
            max-height: 180px;
            overflow-y: auto;
            margin-top: 8px;
        }

        .history-row {
            display: grid;
            grid-template-columns: 30px 1fr 1fr 50px 50px;
            gap: 4px;
            padding: 5px 4px;
            font-size: 0.74rem;
            border-bottom: 1px solid #edf2f7;
            align-items: center;
        }

        .history-row.header {
            font-weight: 600;
            color: #718096;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-size: 0.68rem;
            border-bottom: 2px solid #e2e8f0;
            position: sticky;
            top: 0;
            background: #fff;
        }

        .history-row .rn { color: #a0aec0; text-align: center; }
        .history-row .you-act { color: #2b6cb0; font-weight: 600; text-align: center; }
        .history-row .opp-act { color: #e53e3e; font-weight: 600; text-align: center; }
        .history-row .you-pay { font-family: 'Consolas', monospace; color: #2b6cb0; font-weight: 600; text-align: center; }
        .history-row .opp-pay { font-family: 'Consolas', monospace; color: #e53e3e; font-weight: 600; text-align: center; }

        /* Score bar */
        .score-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 14px;
            background: #f7fafc;
            border: 1px solid #e2e8f0;
            border-radius: 10px;
            margin-bottom: 12px;
        }

        .score-item {
            text-align: center;
        }

        .score-item .sc-label {
            font-size: 0.68rem;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            color: #718096;
        }

        .score-item .sc-value {
            font-size: 1.3rem;
            font-weight: 700;
            font-family: 'Consolas', monospace;
        }

        .score-item .sc-value.blue { color: #2b6cb0; }
        .score-item .sc-value.red { color: #e53e3e; }
        .score-item .sc-value.gray { color: #718096; }

        /* Strategy selector */
        .strat-select {
            width: 100%;
            padding: 8px 10px;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            background: #f7fafc;
            font-size: 0.82rem;
            color: #2d3748;
            font-family: 'Segoe UI', sans-serif;
            cursor: pointer;
            margin-bottom: 8px;
        }

        /* Canvas for charts */
        .chart-panel canvas {
            width: 100%;
            display: block;
        }

        /* Preset buttons */
        .preset-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            margin-bottom: 10px;
        }

        .preset-btn {
            padding: 7px 6px;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            background: #f7fafc;
            cursor: pointer;
            text-align: center;
            font-size: 0.74rem;
            font-weight: 600;
            color: #4a5568;
            transition: all 0.15s;
            font-family: 'Segoe UI', sans-serif;
        }

        .preset-btn:hover {
            border-color: #4299e1;
            background: #ebf8ff;
            color: #2b6cb0;
        }

        .preset-btn.active {
            border-color: #4299e1;
            background: #ebf8ff;
            color: #2b6cb0;
        }

        /* Bottom panel */
        .bottom-panel {
            grid-column: 1 / -1;
        }

        .concepts-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 12px;
            margin-top: 10px;
        }

        .concept-card {
            background: #f7fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 12px;
        }

        .concept-card .cc-label {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            color: #718096;
            margin-bottom: 6px;
            font-weight: 600;
        }

        .concept-card .cc-value {
            font-size: 0.88rem;
            font-weight: 700;
            color: #1a202c;
            margin-bottom: 4px;
        }

        .concept-card .cc-desc {
            font-size: 0.72rem;
            color: #718096;
            line-height: 1.4;
        }

        /* Reset button */
        .reset-btn {
            width: 100%;
            padding: 8px;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            background: #fff;
            cursor: pointer;
            font-size: 0.78rem;
            color: #718096;
            font-weight: 600;
            transition: all 0.15s;
            font-family: 'Segoe UI', sans-serif;
        }

        .reset-btn:hover { border-color: #e53e3e; color: #e53e3e; background: #fff5f5; }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 8px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 0.74rem;
            color: #4a5568;
        }

        .legend-swatch { width: 14px; height: 4px; border-radius: 2px; }

        @media (max-width: 1100px) {
            .app-grid { grid-template-columns: 1fr; }
            .controls-panel { grid-row: auto; }
            .bottom-panel { grid-column: auto; }
            .concepts-grid { grid-template-columns: repeat(2, 1fr); }
        }
    </style>
</head>
<body>
    <h1>Game Theory Lab</h1>
    <p class="subtitle">Play simultaneous-move games against a simulated opponent ‚Äî explore Nash equilibria, dominant strategies &amp; cooperation</p>

    <div class="app-grid">
        <!-- LEFT CONTROLS -->
        <div class="panel controls-panel">
            <div class="panel-title">Game Presets</div>
            <div class="preset-grid">
                <div class="preset-btn active" data-preset="pd">üîí Prisoner's Dilemma</div>
                <div class="preset-btn" data-preset="stag">ü¶å Stag Hunt</div>
                <div class="preset-btn" data-preset="chicken">üêî Chicken</div>
                <div class="preset-btn" data-preset="bos">üíÉ Battle of Sexes</div>
                <div class="preset-btn" data-preset="matching">ü™ô Matching Pennies</div>
                <div class="preset-btn" data-preset="harmony">üïäÔ∏è Harmony</div>
                <div class="preset-btn" data-preset="deadlock">üíÄ Deadlock</div>
                <div class="preset-btn" data-preset="custom">‚öôÔ∏è Custom</div>
            </div>

            <hr class="section-divider">
            <div class="panel-title">Payoff Matrix (You, Opponent)</div>

            <div class="slider-group">
                <div class="slider-label">
                    <span>Both Cooperate (R)</span>
                    <span class="slider-value" id="vR">3</span>
                </div>
                <input type="range" id="sR" min="-5" max="10" value="3" step="1">
            </div>
            <div class="slider-group">
                <div class="slider-label">
                    <span>You Defect, They Coop (T)</span>
                    <span class="slider-value" id="vT">5</span>
                </div>
                <input type="range" id="sT" min="-5" max="10" value="5" step="1">
            </div>
            <div class="slider-group">
                <div class="slider-label">
                    <span>You Coop, They Defect (S)</span>
                    <span class="slider-value" id="vS">0</span>
                </div>
                <input type="range" id="sS" min="-5" max="10" value="0" step="1">
            </div>
            <div class="slider-group">
                <div class="slider-label">
                    <span>Both Defect (P)</span>
                    <span class="slider-value" id="vP">1</span>
                </div>
                <input type="range" id="sP" min="-5" max="10" value="1" step="1">
            </div>

            <div class="equation-box" id="payoffNote">
                Symmetric game: opponent's payoffs mirror yours.<br>
                Classic PD: T > R > P > S and 2R > T + S
            </div>

            <hr class="section-divider">
            <div class="panel-title">Opponent Strategy</div>
            <select class="strat-select" id="stratSelect">
                <option value="tft">Tit-for-Tat</option>
                <option value="random">Random (50/50)</option>
                <option value="always_c">Always Cooperate</option>
                <option value="always_d">Always Defect</option>
                <option value="grudger">Grudger (Grim Trigger)</option>
                <option value="pavlov">Pavlov (Win-Stay Lose-Shift)</option>
                <option value="suspicious_tft">Suspicious Tit-for-Tat</option>
                <option value="nash">Play Nash Equilibrium</option>
            </select>
            <div class="info-box" id="stratDesc">
                <strong>Tit-for-Tat:</strong> Cooperates first, then copies your previous move. One of the most successful strategies in repeated PD tournaments.
            </div>

            <hr class="section-divider">
            <button class="reset-btn" id="resetBtn">‚Ü∫ Reset Game History</button>
        </div>

        <!-- CENTER TOP: Payoff Matrix + Actions -->
        <div class="panel">
            <div id="gameTypeBadge" class="game-type-badge" style="background:#fff5f5; color:#e53e3e;">üîí Prisoner's Dilemma</div>

            <div class="score-bar">
                <div class="score-item">
                    <div class="sc-label">Your Total</div>
                    <div class="sc-value blue" id="scoreYou">0</div>
                </div>
                <div class="score-item">
                    <div class="sc-label">Round</div>
                    <div class="sc-value gray" id="roundNum">0</div>
                </div>
                <div class="score-item">
                    <div class="sc-label">Opponent Total</div>
                    <div class="sc-value red" id="scoreOpp">0</div>
                </div>
            </div>

            <div class="matrix-container">
                <table class="payoff-table" id="payoffTable">
                    <tr>
                        <th class="corner"></th>
                        <th class="col-header">Opp: Cooperate</th>
                        <th class="col-header">Opp: Defect</th>
                    </tr>
                    <tr>
                        <td class="row-label">You: Cooperate</td>
                        <td id="cell_CC"><span class="p1">3</span>, <span class="p2">3</span></td>
                        <td id="cell_CD"><span class="p1">0</span>, <span class="p2">5</span></td>
                    </tr>
                    <tr>
                        <td class="row-label">You: Defect</td>
                        <td id="cell_DC"><span class="p1">5</span>, <span class="p2">0</span></td>
                        <td id="cell_DD"><span class="p1">1</span>, <span class="p2">1</span></td>
                    </tr>
                </table>
            </div>

            <div style="text-align:center; margin: 4px 0; font-size:0.72rem; color:#a0aec0;">
                <span style="color:#38a169;">‚ñ†</span> Nash Equilibrium &nbsp;
                <span style="color:#d69e2e;">‚òÖ</span> Pareto Optimal
            </div>

            <div class="action-buttons">
                <div class="action-btn cooperate" id="btnCoop">
                    <span class="btn-label">ü§ù Cooperate</span>
                    <span class="btn-sub">Trust your opponent</span>
                </div>
                <div class="action-btn defect" id="btnDefect">
                    <span class="btn-label">üó°Ô∏è Defect</span>
                    <span class="btn-sub">Pursue self-interest</span>
                </div>
            </div>

            <div class="round-result" id="roundResult"></div>

            <div class="info-box highlight" id="insightBox">
                Choose an action above to play a round. The payoff matrix shows (your payoff, opponent's payoff) for each outcome.
            </div>
        </div>

        <!-- RIGHT TOP: History + Chart -->
        <div class="panel">
            <div class="panel-title">Game History</div>

            <div class="legend">
                <div class="legend-item"><div class="legend-swatch" style="background:#2b6cb0;"></div> Your Score</div>
                <div class="legend-item"><div class="legend-swatch" style="background:#e53e3e;"></div> Opponent Score</div>
            </div>

            <canvas id="scoreCanvas" width="520" height="160"></canvas>

            <div class="history-scroll" id="historyScroll">
                <div class="history-row header">
                    <div class="rn">#</div>
                    <div class="you-act">You</div>
                    <div class="opp-act">Opponent</div>
                    <div class="you-pay">Yours</div>
                    <div class="opp-pay">Theirs</div>
                </div>
                <div id="historyBody"></div>
            </div>
        </div>

        <!-- RIGHT BOTTOM: Best Response Chart -->
        <div class="panel chart-panel" style="grid-column: 2 / 4;">
            <div class="panel-title">Best Response &amp; Mixed Strategy Analysis</div>
            <div class="legend">
                <div class="legend-item"><div class="legend-swatch" style="background:#2b6cb0;"></div> Your Expected Payoff (Cooperate)</div>
                <div class="legend-item"><div class="legend-swatch" style="background:#e53e3e;"></div> Your Expected Payoff (Defect)</div>
                <div class="legend-item"><div class="legend-swatch" style="background:#38a169; height:8px; width:8px; border-radius:50%;"></div> Nash Equilibrium</div>
            </div>
            <canvas id="brCanvas" width="700" height="220"></canvas>
        </div>

        <!-- BOTTOM: Concepts -->
        <div class="panel bottom-panel">
            <div class="panel-title">Game Analysis</div>
            <div class="concepts-grid" id="conceptsGrid">
            </div>
        </div>
    </div>

    <script>
    (function() {
        // ---- State ----
        let R = 3, T = 5, S = 0, P = 1; // Reward, Temptation, Sucker, Punishment
        let history = []; // [{you: 'C'|'D', opp: 'C'|'D', youPay, oppPay}]
        let yourScore = 0, oppScore = 0;

        // ---- DOM ----
        const sR = document.getElementById('sR'), sT = document.getElementById('sT');
        const sS = document.getElementById('sS'), sP = document.getElementById('sP');
        const vR = document.getElementById('vR'), vT = document.getElementById('vT');
        const vS = document.getElementById('vS'), vP = document.getElementById('vP');

        const scoreCanvas = document.getElementById('scoreCanvas');
        const sCtx = scoreCanvas.getContext('2d');
        const brCanvas = document.getElementById('brCanvas');
        const brCtx = brCanvas.getContext('2d');

        // ---- Presets ----
        const presets = {
            pd:       { R: 3, T: 5, S: 0, P: 1, name: 'üîí Prisoner\'s Dilemma', color: '#e53e3e', bg: '#fff5f5' },
            stag:     { R: 5, T: 3, S: 0, P: 1, name: 'ü¶å Stag Hunt', color: '#2b6cb0', bg: '#ebf8ff' },
            chicken:  { R: 3, T: 5, S: 1, P: 0, name: 'üêî Chicken (Hawk-Dove)', color: '#d69e2e', bg: '#fffff0' },
            bos:      { R: 5, T: 0, S: 0, P: 3, name: 'üíÉ Battle of Sexes', color: '#805ad5', bg: '#faf5ff' },
            matching: { R: 1, T: -1, S: -1, P: 1, name: 'ü™ô Matching Pennies', color: '#718096', bg: '#f7fafc' },
            harmony:  { R: 5, T: 3, S: 3, P: 1, name: 'üïäÔ∏è Harmony Game', color: '#38a169', bg: '#f0fff4' },
            deadlock: { R: 1, T: 5, S: 0, P: 3, name: 'üíÄ Deadlock', color: '#4a5568', bg: '#f7fafc' },
            custom:   { R: R, T: T, S: S, P: P, name: '‚öôÔ∏è Custom', color: '#4299e1', bg: '#ebf8ff' },
        };

        let activePreset = 'pd';

        document.querySelectorAll('.preset-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                activePreset = btn.dataset.preset;
                document.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                if (activePreset !== 'custom') {
                    const p = presets[activePreset];
                    R = p.R; T = p.T; S = p.S; P = p.P;
                    sR.value = R; sT.value = T; sS.value = S; sP.value = P;
                }
                resetGame();
                updateAll();
            });
        });

        // ---- Slider events ----
        [sR, sT, sS, sP].forEach(s => {
            s.addEventListener('input', () => {
                R = parseInt(sR.value); T = parseInt(sT.value);
                S = parseInt(sS.value); P = parseInt(sP.value);
                // Switch to custom if values don't match any preset
                let matched = false;
                for (const [key, p] of Object.entries(presets)) {
                    if (key === 'custom') continue;
                    if (p.R === R && p.T === T && p.S === S && p.P === P) {
                        activePreset = key;
                        matched = true;
                        break;
                    }
                }
                if (!matched) activePreset = 'custom';
                document.querySelectorAll('.preset-btn').forEach(b => {
                    b.classList.toggle('active', b.dataset.preset === activePreset);
                });
                updateAll();
            });
        });

        // ---- Strategy descriptions ----
        const stratDescs = {
            tft: '<strong>Tit-for-Tat:</strong> Cooperates first, then copies your last move. Simple, forgiving, retaliatory.',
            random: '<strong>Random:</strong> Cooperates 50% of the time, independent of history. Unpredictable baseline.',
            always_c: '<strong>Always Cooperate:</strong> Cooperates unconditionally. Exploitable but maximizes joint payoff if you cooperate too.',
            always_d: '<strong>Always Defect:</strong> Never cooperates. Maximizes own payoff against cooperators.',
            grudger: '<strong>Grim Trigger:</strong> Cooperates until you defect once, then defects forever. Harsh but effective deterrent.',
            pavlov: '<strong>Pavlov:</strong> Repeats last action if it got R or T (high payoff); switches if it got S or P. "Win-stay, lose-shift."',
            suspicious_tft: '<strong>Suspicious TfT:</strong> Like Tit-for-Tat but defects first. Tests you before trusting.',
            nash: '<strong>Nash Strategy:</strong> Plays the Nash equilibrium strategy (pure or mixed). The rational benchmark.',
        };

        document.getElementById('stratSelect').addEventListener('change', function() {
            document.getElementById('stratDesc').innerHTML = stratDescs[this.value];
        });

        // ---- Game classification ----
        function classifyGame() {
            // T > R > P > S => Prisoner's Dilemma (also need 2R > T+S for iterated)
            // R > T > P > S => Stag Hunt
            // T > R > S > P => Chicken / Hawk-Dove
            // R > T, R > S, P > S, P > T ish => not standard

            if (T > R && R > P && P > S) return 'pd';
            if (R > T && R > P && P > S && T > S) return 'stag';
            if (T > R && R > S && S > P) return 'chicken';
            if (R > T && R > S && P > T && P > S) return 'harmony';
            if (P > R && T > R) return 'deadlock';
            if (R > T && T === S && S < P) return 'bos';
            if (R === P && T === -S) return 'matching';
            return 'custom';
        }

        // ---- Nash equilibria ----
        function findNashEquilibria() {
            // Payoff matrix for row player (you):
            //           Opp C    Opp D
            // You C:     R        S
            // You D:     T        P
            // Opp is symmetric: their payoffs are R, T, S, P mirrored

            const nash = [];

            // Check pure strategy NE
            // (C,C): You have no incentive to deviate if R >= T; Opp has no incentive if R >= T
            if (R >= T && R >= T) nash.push({ you: 'C', opp: 'C' });
            // (C,D): You stay C if S >= P; Opp stays D if T >= R
            if (S >= P && T >= R) nash.push({ you: 'C', opp: 'D' });
            // (D,C): You stay D if T >= R; Opp stays C if S >= P
            if (T >= R && S >= P) nash.push({ you: 'D', opp: 'C' });
            // (D,D): You stay D if P >= S; Opp stays D if P >= S
            if (P >= S && P >= S) nash.push({ you: 'D', opp: 'D' });

            // Mixed strategy NE
            // You: indifferent when opp plays C with prob q:
            // q*R + (1-q)*S = q*T + (1-q)*P
            // q*(R-T) = (1-q)*(P-S) = P - S - q*(P-S)
            // q*(R - T + P - S) = P - S
            // q = (P - S) / (R - T + P - S)
            const denom = R - T + P - S;
            let mixedQ = null, mixedP_you = null;
            if (Math.abs(denom) > 0.001) {
                mixedQ = (P - S) / denom;
                // By symmetry, you play C with same probability
                mixedP_you = (P - S) / denom; // same formula in symmetric game
                if (mixedQ > 0.001 && mixedQ < 0.999) {
                    // Valid interior mixed NE
                }
            }

            return { pure: nash, mixedQ, mixedP_you };
        }

        // ---- Dominant strategies ----
        function findDominantStrategies() {
            // For you: C dominates D if R > T and S > P
            // D dominates C if T > R and P > S
            let youDom = null;
            if (R > T && S > P) youDom = 'C';
            else if (R >= T && S >= P && (R > T || S > P)) youDom = 'C (weakly)';
            else if (T > R && P > S) youDom = 'D';
            else if (T >= R && P >= S && (T > R || P > S)) youDom = 'D (weakly)';

            return youDom;
        }

        // ---- Pareto optimality ----
        function findParetoOptimal() {
            const outcomes = [
                { you: 'C', opp: 'C', y: R, o: R },
                { you: 'C', opp: 'D', y: S, o: T },
                { you: 'D', opp: 'C', y: T, o: S },
                { you: 'D', opp: 'D', y: P, o: P },
            ];
            return outcomes.filter(a =>
                !outcomes.some(b => b.y >= a.y && b.o >= a.o && (b.y > a.y || b.o > a.o))
            );
        }

        // ---- Opponent strategy ----
        function opponentMove(strat) {
            const n = history.length;
            if (strat === 'always_c') return 'C';
            if (strat === 'always_d') return 'D';
            if (strat === 'random') return Math.random() < 0.5 ? 'C' : 'D';
            if (strat === 'tft') return n === 0 ? 'C' : history[n - 1].you;
            if (strat === 'suspicious_tft') return n === 0 ? 'D' : history[n - 1].you;
            if (strat === 'grudger') {
                if (history.some(h => h.you === 'D')) return 'D';
                return 'C';
            }
            if (strat === 'pavlov') {
                if (n === 0) return 'C';
                const last = history[n - 1];
                const lastPay = last.opp === 'C'
                    ? (last.you === 'C' ? R : S)  // opp got R or S
                    : (last.you === 'C' ? T : P);  // opp got T or P
                // Actually for the opponent: if opp cooperated last and got R or T => good
                const oppLastAction = last.opp;
                const oppLastPay = last.oppPay;
                // Win-stay: if got R or T (high), keep same; else switch
                if (oppLastPay >= R) return oppLastAction;
                return oppLastAction === 'C' ? 'D' : 'C';
            }
            if (strat === 'nash') {
                const ne = findNashEquilibria();
                // If pure NE exists, play the first one's opp action
                if (ne.pure.length > 0) return ne.pure[0].opp;
                // Mixed
                if (ne.mixedQ !== null && ne.mixedQ >= 0 && ne.mixedQ <= 1) {
                    return Math.random() < ne.mixedQ ? 'C' : 'D';
                }
                return Math.random() < 0.5 ? 'C' : 'D';
            }
            return 'C';
        }

        function payoffs(you, opp) {
            if (you === 'C' && opp === 'C') return [R, R];
            if (you === 'C' && opp === 'D') return [S, T];
            if (you === 'D' && opp === 'C') return [T, S];
            return [P, P];
        }

        // ---- Play a round ----
        function playRound(yourAction) {
            const strat = document.getElementById('stratSelect').value;
            const oppAction = opponentMove(strat);
            const [yPay, oPay] = payoffs(yourAction, oppAction);
            history.push({ you: yourAction, opp: oppAction, youPay: yPay, oppPay: oPay });
            yourScore += yPay;
            oppScore += oPay;

            // Show result
            const res = document.getElementById('roundResult');
            const youLabel = yourAction === 'C' ? 'Cooperated' : 'Defected';
            const oppLabel = oppAction === 'C' ? 'Cooperated' : 'Defected';
            const youColor = yourAction === 'C' ? '#38a169' : '#e53e3e';
            const oppColor = oppAction === 'C' ? '#38a169' : '#e53e3e';
            res.style.background = yPay >= oPay ? '#f0fff4' : '#fff5f5';
            res.style.border = `1px solid ${yPay >= oPay ? '#c6f6d5' : '#fed7d7'}`;
            res.innerHTML = `
                <span style="color:${youColor}; font-weight:700;">You ${youLabel}</span> &nbsp;vs&nbsp;
                <span style="color:${oppColor}; font-weight:700;">Opponent ${oppLabel}</span><br>
                <span style="color:#2b6cb0; font-weight:700;">+${yPay}</span> for you,
                <span style="color:#e53e3e; font-weight:700;">+${oPay}</span> for opponent
            `;
            res.classList.add('show');

            updateScores();
            addHistoryRow();
            drawScoreChart();
            updateInsight();
        }

        document.getElementById('btnCoop').addEventListener('click', () => playRound('C'));
        document.getElementById('btnDefect').addEventListener('click', () => playRound('D'));

        function resetGame() {
            history = [];
            yourScore = 0;
            oppScore = 0;
            updateScores();
            document.getElementById('historyBody').innerHTML = '';
            document.getElementById('roundResult').classList.remove('show');
            drawScoreChart();
            updateInsight();
        }

        document.getElementById('resetBtn').addEventListener('click', resetGame);

        // ---- UI Updates ----
        function updateScores() {
            document.getElementById('scoreYou').textContent = yourScore;
            document.getElementById('scoreOpp').textContent = oppScore;
            document.getElementById('roundNum').textContent = history.length;
        }

        function addHistoryRow() {
            const h = history[history.length - 1];
            const body = document.getElementById('historyBody');
            const row = document.createElement('div');
            row.className = 'history-row';
            row.innerHTML = `
                <div class="rn">${history.length}</div>
                <div class="you-act">${h.you === 'C' ? 'ü§ù' : 'üó°Ô∏è'}</div>
                <div class="opp-act">${h.opp === 'C' ? 'ü§ù' : 'üó°Ô∏è'}</div>
                <div class="you-pay">${h.youPay >= 0 ? '+' : ''}${h.youPay}</div>
                <div class="opp-pay">${h.oppPay >= 0 ? '+' : ''}${h.oppPay}</div>
            `;
            body.appendChild(row);
            document.getElementById('historyScroll').scrollTop = 99999;
        }

        function updateMatrix() {
            vR.textContent = R; vT.textContent = T; vS.textContent = S; vP.textContent = P;

            const ne = findNashEquilibria();
            const pareto = findParetoOptimal();

            const cells = {
                CC: document.getElementById('cell_CC'),
                CD: document.getElementById('cell_CD'),
                DC: document.getElementById('cell_DC'),
                DD: document.getElementById('cell_DD'),
            };

            cells.CC.innerHTML = `<span class="p1">${R}</span>, <span class="p2">${R}</span>`;
            cells.CD.innerHTML = `<span class="p1">${S}</span>, <span class="p2">${T}</span>`;
            cells.DC.innerHTML = `<span class="p1">${T}</span>, <span class="p2">${S}</span>`;
            cells.DD.innerHTML = `<span class="p1">${P}</span>, <span class="p2">${P}</span>`;

            // Clear classes
            Object.values(cells).forEach(c => { c.className = ''; });

            // Mark Nash
            ne.pure.forEach(n => {
                const key = n.you + n.opp;
                if (cells[key]) cells[key].classList.add('nash');
            });

            // Mark Pareto
            pareto.forEach(p => {
                const key = p.you + p.opp;
                if (cells[key]) cells[key].classList.add('pareto-optimal');
            });
        }

        function updateGameBadge() {
            const badge = document.getElementById('gameTypeBadge');
            const type = classifyGame();
            const p = presets[type] || presets.custom;
            badge.textContent = p.name;
            badge.style.background = p.bg;
            badge.style.color = p.color;
        }

        function updateInsight() {
            const box = document.getElementById('insightBox');
            const ne = findNashEquilibria();
            const dom = findDominantStrategies();
            const n = history.length;

            if (n === 0) {
                let text = '';
                if (ne.pure.length === 1) {
                    const eq = ne.pure[0];
                    text = `This game has a unique pure-strategy Nash equilibrium at <strong>(${eq.you}, ${eq.opp})</strong>. `;
                } else if (ne.pure.length > 1) {
                    text = `This game has <strong>${ne.pure.length} pure-strategy Nash equilibria</strong>: ${ne.pure.map(n => `(${n.you},${n.opp})`).join(', ')}. Coordination is the challenge. `;
                } else {
                    text = `No pure-strategy NE. `;
                }
                if (ne.mixedQ !== null && ne.mixedQ > 0.001 && ne.mixedQ < 0.999) {
                    text += `Mixed NE: each cooperates with probability <strong>${(ne.mixedQ * 100).toFixed(0)}%</strong>. `;
                }
                if (dom) {
                    text += `You have a dominant strategy: <strong>${dom}</strong>. `;
                }
                text += 'Make your first move!';
                box.className = 'info-box highlight';
                box.innerHTML = text;
            } else {
                const coopRate = history.filter(h => h.you === 'C').length / n;
                const oppCoopRate = history.filter(h => h.opp === 'C').length / n;
                const avgYou = yourScore / n;
                const avgOpp = oppScore / n;
                const mutual = avgYou + avgOpp;

                let verdict = '';
                if (avgYou > avgOpp + 0.5) verdict = 'You\'re winning! ';
                else if (avgOpp > avgYou + 0.5) verdict = 'Opponent is ahead. ';
                else verdict = 'Scores are close. ';

                if (coopRate > 0.7 && oppCoopRate > 0.7) verdict += 'Mutual cooperation is sustaining high joint payoffs.';
                else if (coopRate < 0.3 && oppCoopRate < 0.3) verdict += 'Mutual defection ‚Äî the classic trap.';
                else if (coopRate > 0.7 && oppCoopRate < 0.3) verdict += 'You\'re being exploited! Consider defecting.';
                else if (coopRate < 0.3 && oppCoopRate > 0.7) verdict += 'You\'re exploiting a cooperator.';
                else verdict += 'Mixed play pattern.';

                box.className = 'info-box highlight';
                box.innerHTML = `<strong>After ${n} rounds:</strong> ${verdict}<br>
                    Your avg: ${avgYou.toFixed(1)}/round (${(coopRate * 100).toFixed(0)}% coop) &nbsp;|&nbsp;
                    Opp avg: ${avgOpp.toFixed(1)}/round (${(oppCoopRate * 100).toFixed(0)}% coop)`;
            }
        }

        function updateConcepts() {
            const ne = findNashEquilibria();
            const dom = findDominantStrategies();
            const pareto = findParetoOptimal();
            const type = classifyGame();

            const paretoStr = pareto.map(p => `(${p.you},${p.opp})`).join(', ');
            const neStr = ne.pure.length > 0
                ? ne.pure.map(n => `(${n.you},${n.opp})`).join(', ')
                : 'None (pure)';

            let mixedStr = 'N/A';
            if (ne.mixedQ !== null && ne.mixedQ > 0.001 && ne.mixedQ < 0.999) {
                mixedStr = `p(C) = ${(ne.mixedQ * 100).toFixed(0)}%`;
            } else if (ne.pure.length > 0) {
                mixedStr = 'Pure NE exists';
            }

            // Check for social dilemma
            let dilemma = 'None';
            if (type === 'pd') dilemma = 'Individual rationality leads to mutual defection, but mutual cooperation is Pareto superior.';
            else if (type === 'stag') dilemma = 'Two equilibria ‚Äî the risk-dominant (D,D) vs. the payoff-dominant (C,C). Trust is key.';
            else if (type === 'chicken') dilemma = 'Both want the other to yield. Two asymmetric NE plus a mixed NE. Escalation risk.';
            else if (type === 'harmony') dilemma = 'No dilemma ‚Äî cooperation is individually rational. The market works!';

            document.getElementById('conceptsGrid').innerHTML = `
                <div class="concept-card">
                    <div class="cc-label">Nash Equilibria</div>
                    <div class="cc-value">${neStr}</div>
                    <div class="cc-desc">No player can unilaterally improve their payoff by switching strategies.</div>
                </div>
                <div class="concept-card">
                    <div class="cc-label">Dominant Strategy</div>
                    <div class="cc-value">${dom || 'None'}</div>
                    <div class="cc-desc">A strategy that yields a higher payoff regardless of what the opponent does.</div>
                </div>
                <div class="concept-card">
                    <div class="cc-label">Pareto Optimal</div>
                    <div class="cc-value">${paretoStr}</div>
                    <div class="cc-desc">No other outcome makes someone better off without making the other worse off. ‚òÖ in matrix.</div>
                </div>
                <div class="concept-card">
                    <div class="cc-label">Social Dilemma</div>
                    <div class="cc-value" style="font-size:0.8rem;">${type === 'custom' ? 'Custom game' : presets[type].name}</div>
                    <div class="cc-desc">${dilemma}</div>
                </div>
            `;
        }

        // ---- Charts ----
        function setupCanvas(canvas, ctx) {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            return { w: rect.width, h: rect.height };
        }

        function drawScoreChart() {
            const { w, h } = setupCanvas(scoreCanvas, sCtx);
            const ctx = sCtx;
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, w, h);

            if (history.length === 0) {
                ctx.fillStyle = '#a0aec0';
                ctx.font = '12px Segoe UI';
                ctx.textAlign = 'center';
                ctx.fillText('Play rounds to see cumulative score chart', w / 2, h / 2);
                return;
            }

            const pad = { top: 10, right: 15, bottom: 24, left: 40 };

            // Cumulative scores
            let cumYou = [], cumOpp = [];
            let sy = 0, so = 0;
            history.forEach(h => {
                sy += h.youPay; so += h.oppPay;
                cumYou.push(sy);
                cumOpp.push(so);
            });

            const maxVal = Math.max(...cumYou, ...cumOpp, 1);
            const minVal = Math.min(...cumYou, ...cumOpp, 0);
            const range = maxVal - minVal || 1;

            function X(i) { return pad.left + (i / Math.max(history.length - 1, 1)) * (w - pad.left - pad.right); }
            function Y(v) { return h - pad.bottom - ((v - minVal) / range) * (h - pad.top - pad.bottom); }

            // Grid
            ctx.strokeStyle = '#edf2f7'; ctx.lineWidth = 0.5;
            for (let i = 0; i <= 4; i++) {
                const v = minVal + range * i / 4;
                ctx.beginPath(); ctx.moveTo(pad.left, Y(v)); ctx.lineTo(w - pad.right, Y(v)); ctx.stroke();
                ctx.fillStyle = '#a0aec0'; ctx.font = '9px Consolas'; ctx.textAlign = 'right';
                ctx.fillText(v.toFixed(0), pad.left - 4, Y(v) + 3);
            }

            // Lines
            function drawLine(data, color) {
                ctx.strokeStyle = color; ctx.lineWidth = 2;
                ctx.beginPath();
                data.forEach((v, i) => {
                    if (i === 0) ctx.moveTo(X(i), Y(v));
                    else ctx.lineTo(X(i), Y(v));
                });
                ctx.stroke();
            }

            drawLine(cumYou, '#2b6cb0');
            drawLine(cumOpp, '#e53e3e');

            // X axis labels
            ctx.fillStyle = '#a0aec0'; ctx.font = '9px Consolas'; ctx.textAlign = 'center';
            const step = Math.max(1, Math.floor(history.length / 8));
            for (let i = 0; i < history.length; i += step) {
                ctx.fillText(i + 1, X(i), h - 6);
            }
            if (history.length > 1) ctx.fillText(history.length, X(history.length - 1), h - 6);
        }

        function drawBRChart() {
            const { w, h } = setupCanvas(brCanvas, brCtx);
            const ctx = brCtx;
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, w, h);

            const pad = { top: 14, right: 20, bottom: 32, left: 48 };

            // X axis: opponent's probability of cooperating (q)
            // Your expected payoff from C: q*R + (1-q)*S
            // Your expected payoff from D: q*T + (1-q)*P

            const allVals = [R, T, S, P];
            const maxP = Math.max(...allVals) + 1;
            const minP = Math.min(...allVals) - 1;
            const range = maxP - minP;

            function X(q) { return pad.left + q * (w - pad.left - pad.right); }
            function Y(v) { return h - pad.bottom - ((v - minP) / range) * (h - pad.top - pad.bottom); }

            // Grid
            ctx.strokeStyle = '#edf2f7'; ctx.lineWidth = 0.5;
            for (let i = 0; i <= 5; i++) {
                const v = minP + range * i / 5;
                ctx.beginPath(); ctx.moveTo(pad.left, Y(v)); ctx.lineTo(w - pad.right, Y(v)); ctx.stroke();
                ctx.fillStyle = '#a0aec0'; ctx.font = '10px Consolas'; ctx.textAlign = 'right';
                ctx.fillText(v.toFixed(1), pad.left - 5, Y(v) + 3);
            }
            for (let i = 0; i <= 10; i++) {
                const q = i / 10;
                const x = X(q);
                ctx.beginPath(); ctx.moveTo(x, pad.top); ctx.lineTo(x, h - pad.bottom); ctx.stroke();
                ctx.fillStyle = '#a0aec0'; ctx.font = '10px Consolas'; ctx.textAlign = 'center';
                if (i % 2 === 0) ctx.fillText(q.toFixed(1), x, h - pad.bottom + 14);
            }

            // Axes
            ctx.strokeStyle = '#a0aec0'; ctx.lineWidth = 1.2;
            ctx.beginPath();
            ctx.moveTo(pad.left, pad.top);
            ctx.lineTo(pad.left, h - pad.bottom);
            ctx.lineTo(w - pad.right, h - pad.bottom);
            ctx.stroke();

            // Labels
            ctx.fillStyle = '#4a5568'; ctx.font = '11px Segoe UI'; ctx.textAlign = 'center';
            ctx.fillText('Opponent\'s Probability of Cooperating (q)', (pad.left + w - pad.right) / 2, h - 2);
            ctx.save(); ctx.translate(14, (pad.top + h - pad.bottom) / 2); ctx.rotate(-Math.PI / 2);
            ctx.fillText('Your Expected Payoff', 0, 0); ctx.restore();

            // E[C] = q*R + (1-q)*S line
            ctx.strokeStyle = '#2b6cb0'; ctx.lineWidth = 2.5;
            ctx.beginPath();
            ctx.moveTo(X(0), Y(S));
            ctx.lineTo(X(1), Y(R));
            ctx.stroke();

            // E[D] = q*T + (1-q)*P line
            ctx.strokeStyle = '#e53e3e'; ctx.lineWidth = 2.5;
            ctx.beginPath();
            ctx.moveTo(X(0), Y(P));
            ctx.lineTo(X(1), Y(T));
            ctx.stroke();

            // Shade best response regions
            for (let qi = 0; qi < 100; qi++) {
                const q = qi / 100;
                const ec = q * R + (1 - q) * S;
                const ed = q * T + (1 - q) * P;
                const x = X(q);
                const xn = X((qi + 1) / 100);
                if (ec > ed + 0.05) {
                    ctx.fillStyle = 'rgba(43, 108, 176, 0.06)';
                    ctx.fillRect(x, pad.top, xn - x, h - pad.top - pad.bottom);
                } else if (ed > ec + 0.05) {
                    ctx.fillStyle = 'rgba(229, 62, 62, 0.06)';
                    ctx.fillRect(x, pad.top, xn - x, h - pad.top - pad.bottom);
                }
            }

            // Redraw lines on top
            ctx.strokeStyle = '#2b6cb0'; ctx.lineWidth = 2.5;
            ctx.beginPath(); ctx.moveTo(X(0), Y(S)); ctx.lineTo(X(1), Y(R)); ctx.stroke();
            ctx.strokeStyle = '#e53e3e'; ctx.lineWidth = 2.5;
            ctx.beginPath(); ctx.moveTo(X(0), Y(P)); ctx.lineTo(X(1), Y(T)); ctx.stroke();

            // Intersection point (mixed NE)
            const denom = R - T + P - S;
            if (Math.abs(denom) > 0.001) {
                const qStar = (P - S) / denom;
                if (qStar > 0.01 && qStar < 0.99) {
                    const eStar = qStar * R + (1 - qStar) * S;
                    // Dashed lines to intersection
                    ctx.setLineDash([3, 3]); ctx.strokeStyle = '#38a169'; ctx.lineWidth = 1;
                    ctx.beginPath(); ctx.moveTo(X(qStar), Y(minP)); ctx.lineTo(X(qStar), Y(eStar)); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(pad.left, Y(eStar)); ctx.lineTo(X(qStar), Y(eStar)); ctx.stroke();
                    ctx.setLineDash([]);

                    // Point
                    ctx.fillStyle = '#38a169';
                    ctx.beginPath(); ctx.arc(X(qStar), Y(eStar), 6, 0, Math.PI * 2); ctx.fill();
                    ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.stroke();

                    // Label
                    ctx.fillStyle = '#38a169'; ctx.font = 'bold 11px Segoe UI'; ctx.textAlign = 'left';
                    ctx.fillText(`Mixed NE: q*=${qStar.toFixed(2)}`, X(qStar) + 10, Y(eStar) - 4);
                    ctx.font = '10px Segoe UI';
                    ctx.fillText(`E[payoff]=${eStar.toFixed(1)}`, X(qStar) + 10, Y(eStar) + 12);
                }
            }

            // Endpoint labels
            ctx.font = 'bold 10px Segoe UI';
            ctx.fillStyle = '#2b6cb0'; ctx.textAlign = 'left';
            ctx.fillText(`E[C]`, X(1) + 4, Y(R) + 3);
            ctx.fillStyle = '#2b6cb0'; ctx.textAlign = 'right';
            ctx.fillText(`S=${S}`, X(0) - 4, Y(S) + 3);

            ctx.fillStyle = '#e53e3e'; ctx.textAlign = 'left';
            ctx.fillText(`E[D]`, X(1) + 4, Y(T) + 3);
            ctx.fillStyle = '#e53e3e'; ctx.textAlign = 'right';
            ctx.fillText(`P=${P}`, X(0) - 4, Y(P) + 3);

            // Best response annotation
            ctx.fillStyle = '#718096'; ctx.font = '10px Segoe UI'; ctx.textAlign = 'center';
            if (R > T && S > P) {
                ctx.fillText('C always dominates ‚Üí always cooperate', (pad.left + w - pad.right) / 2, pad.top + 14);
            } else if (T > R && P > S) {
                ctx.fillText('D always dominates ‚Üí always defect', (pad.left + w - pad.right) / 2, pad.top + 14);
            } else if (Math.abs(denom) > 0.001) {
                const qS = (P - S) / denom;
                if (qS > 0.01 && qS < 0.99) {
                    ctx.fillText(`Best response switches at q = ${qS.toFixed(2)}`, (pad.left + w - pad.right) / 2, pad.top + 14);
                }
            }
        }

        // ---- Master update ----
        function updateAll() {
            updateMatrix();
            updateGameBadge();
            updateConcepts();
            updateInsight();
            drawScoreChart();
            drawBRChart();

            // Update payoff note
            const type = classifyGame();
            const note = document.getElementById('payoffNote');
            if (type === 'pd') note.innerHTML = 'Symmetric game: T > R > P > S<br><strong>Prisoner\'s Dilemma:</strong> Defection dominates, but mutual cooperation is better for both.';
            else if (type === 'stag') note.innerHTML = 'Symmetric game: R > T > P > S<br><strong>Stag Hunt:</strong> Cooperation is best if both trust; defection is safe.';
            else if (type === 'chicken') note.innerHTML = 'Symmetric game: T > R > S > P<br><strong>Chicken:</strong> Both want the other to yield. Worst outcome is mutual defection.';
            else if (type === 'harmony') note.innerHTML = 'Symmetric game: R > T, S > P<br><strong>Harmony:</strong> Cooperation dominates ‚Äî no dilemma at all!';
            else if (type === 'deadlock') note.innerHTML = 'Symmetric game: P > R, T dominant<br><strong>Deadlock:</strong> Both prefer defection and neither gains from cooperation.';
            else note.innerHTML = 'Symmetric game: opponent\'s payoffs mirror yours.<br>Adjust sliders to explore different game structures.';
        }

        // ---- Init ----
        updateAll();
        window.addEventListener('resize', () => { drawScoreChart(); drawBRChart(); });
    })();
    </script>
</body>
</html>
